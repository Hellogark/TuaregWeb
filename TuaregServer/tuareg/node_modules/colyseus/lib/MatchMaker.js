"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var memshared = require("memshared");
var EventEmitter = require("events");
var Utils_1 = require("./Utils");
var index_1 = require("./index");
var Protocol_1 = require("./Protocol");
var Debug_1 = require("./Debug");
;
var RegisteredHandler = /** @class */ (function (_super) {
    __extends(RegisteredHandler, _super);
    function RegisteredHandler(klass, options) {
        var _this = _super.call(this) || this;
        _this.klass = klass;
        _this.options = options;
        return _this;
    }
    return RegisteredHandler;
}(EventEmitter));
exports.RegisteredHandler = RegisteredHandler;
var MatchMaker = /** @class */ (function () {
    function MatchMaker() {
        var _this = this;
        this.handlers = {};
        this.availableRooms = {};
        this.roomsById = {};
        // room references by client id
        this.sessions = {};
        this.connectingClientByRoom = {};
        this.onClientLeaveRoom = function (room, client, isDisconnect) {
            if (isDisconnect) {
                return true;
            }
            delete _this.sessions[client.sessionId];
        };
    }
    MatchMaker.prototype.bindClient = function (client, roomId) {
        var _this = this;
        this.onJoin(roomId, client, function (err, room) {
            if (!err) {
                client.on('message', function (message) {
                    if (!(message = Protocol_1.decode(message))) {
                        return;
                    }
                    _this.execute(client, message);
                });
                client.on('close', function (_) { return _this.onLeave(client, room); });
                client.on('error', function (e) { return console.error("[ERROR]", client.id, e); });
            }
        });
    };
    MatchMaker.prototype.execute = function (client, message) {
        if (message[0] == Protocol_1.Protocol.JOIN_ROOM) {
            this.onJoinRoomRequest(message[1], message[2], false, function (err, room) {
                if (err) {
                    var roomId = (room) ? room.roomId : message[1];
                    Protocol_1.send(client, [Protocol_1.Protocol.JOIN_ERROR, roomId, err]);
                }
            });
        }
        else if (message[0] == Protocol_1.Protocol.ROOM_DATA) {
            // send message directly to specific room
            var room = this.getRoomById(message[1]);
            if (room) {
                room.onMessage(client, message[2]);
            }
        }
        else {
            this.sessions[client.sessionId].onMessage(client, message);
        }
    };
    /**
     * Create/joins a particular client in a room running in a worker process.
     *
     * The client doesn't join instantly because this method is called from the
     * match-making process. The client will request a new WebSocket connection
     * to effectively join into the room created/joined by this method.
     */
    MatchMaker.prototype.onJoinRoomRequest = function (roomToJoin, clientOptions, allowCreateRoom, callback) {
        var room;
        var err;
        clientOptions.sessionId = index_1.generateId();
        if (this.hasHandler(roomToJoin)) {
            room = this.requestToJoinRoom(roomToJoin, clientOptions).room
                || (allowCreateRoom && this.create(roomToJoin, clientOptions));
        }
        else if (index_1.isValidId(roomToJoin)) {
            room = this.joinById(roomToJoin, clientOptions);
        }
        if (room) {
            //
            // Reserve a seat for clientId
            //
            if (!this.connectingClientByRoom[room.roomId]) {
                this.connectingClientByRoom[room.roomId] = {};
            }
            this.connectingClientByRoom[room.roomId][clientOptions.clientId] = clientOptions;
        }
        else {
            err = "join_request_fail";
        }
        callback(err, room);
    };
    /**
     * Binds target client to the room running in a worker process.
     */
    MatchMaker.prototype.onJoin = function (roomId, client, callback) {
        var room = this.roomsById[roomId];
        var err;
        var clientOptions = this.connectingClientByRoom[roomId] && this.connectingClientByRoom[roomId][client.id];
        if (room && clientOptions) {
            // assign sessionId to socket connection.
            client.sessionId = clientOptions.sessionId;
            delete clientOptions.sessionId;
            delete clientOptions.clientId;
            room._onJoin(client, clientOptions);
            room.once('leave', this.onClientLeaveRoom.bind(this, room));
            this.sessions[client.sessionId] = room;
            // emit 'join' on registered handler
            this.handlers[room.roomName].emit("join", room, client);
        }
        else {
            err = "trying to join non-existing room";
            Debug_1.debugMatchMaking("JOIN_ERROR: " + err + " (roomId: %s, clientOptions: %j)", roomId, clientOptions);
            Protocol_1.send(client, [Protocol_1.Protocol.JOIN_ERROR, roomId, err]);
        }
        callback(err, room);
    };
    MatchMaker.prototype.onLeave = function (client, room) {
        room._onLeave(client, true);
        // emit 'leave' on registered handler
        this.handlers[room.roomName].emit("leave", room, client);
    };
    MatchMaker.prototype.registerHandler = function (name, klass, options) {
        if (options === void 0) { options = {}; }
        memshared.sadd("handlers", name);
        var registeredHandler = new RegisteredHandler(klass, options);
        this.handlers[name] = registeredHandler;
        this.availableRooms[name] = [];
        return registeredHandler;
    };
    MatchMaker.prototype.hasHandler = function (name) {
        return this.handlers[name] !== undefined;
    };
    MatchMaker.prototype.hasAvailableRoom = function (roomName) {
        return (this.availableRooms[roomName] &&
            this.availableRooms[roomName].length > 0);
    };
    MatchMaker.prototype.getRoomById = function (roomId) {
        return this.roomsById[roomId];
    };
    MatchMaker.prototype.joinById = function (roomId, clientOptions) {
        var room = this.roomsById[roomId];
        if (!room) {
            console.error("Error: trying to join non-existant room \"" + roomId + "\"");
        }
        else if (!room.requestJoin(clientOptions)) {
            console.error("Error can't join \"" + room.roomName + "\" with options: " + JSON.stringify(clientOptions));
            room = undefined;
        }
        return room;
    };
    MatchMaker.prototype.requestToJoinRoom = function (roomName, clientOptions) {
        var room;
        var bestScore = 0;
        if (this.hasAvailableRoom(roomName)) {
            for (var i = 0; i < this.availableRooms[roomName].length; i++) {
                var availableRoom = this.availableRooms[roomName][i];
                var numConnectedClients = availableRoom.clients.length + Object.keys(this.connectingClientByRoom[availableRoom.roomId] || {}).length;
                // Check maxClients before requesting to join.
                if (numConnectedClients > availableRoom.maxClients) {
                    continue;
                }
                var score = availableRoom.requestJoin(clientOptions);
                if (score > bestScore) {
                    bestScore = score;
                    room = availableRoom;
                }
            }
        }
        return {
            room: room,
            score: bestScore
        };
    };
    MatchMaker.prototype.create = function (roomName, clientOptions) {
        var room = null, registeredHandler = this.handlers[roomName];
        room = new registeredHandler.klass();
        // set room options
        room.roomId = index_1.generateId();
        room.roomName = roomName;
        if (room.onInit) {
            room.onInit(Utils_1.merge({}, clientOptions, registeredHandler.options));
        }
        // cache on which process the room is living.
        memshared.set(room.roomId, process.pid);
        // imediatelly ask client to join the room
        if (room.requestJoin(clientOptions)) {
            registeredHandler.emit("create", room);
            Debug_1.debugMatchMaking("spawning '%s' on worker %d", roomName, process.pid);
            room.on('lock', this.lockRoom.bind(this, roomName, room));
            room.on('unlock', this.unlockRoom.bind(this, roomName, room));
            room.once('dispose', this.disposeRoom.bind(this, roomName, room));
            this.roomsById[room.roomId] = room;
            // room always start unlocked
            this.unlockRoom(roomName, room);
        }
        else {
            room._dispose();
            room = null;
        }
        return room;
    };
    MatchMaker.prototype.lockRoom = function (roomName, room) {
        if (this.hasAvailableRoom(roomName)) {
            var roomIndex = this.availableRooms[roomName].indexOf(room);
            if (roomIndex !== -1) {
                // decrease number of rooms spawned on this worker
                memshared.decr(process.pid.toString());
            }
            Utils_1.spliceOne(this.availableRooms[roomName], roomIndex);
        }
        //
        // if current worker doesn't have any 'rooName' handlers available
        // anymore, remove it from the list.
        //
        if (!this.hasAvailableRoom(roomName)) {
            memshared.srem(room.roomName, process.pid);
        }
    };
    MatchMaker.prototype.unlockRoom = function (roomName, room) {
        if (this.availableRooms[roomName].indexOf(room) === -1) {
            this.availableRooms[roomName].push(room);
            // flag current worker has this room id
            memshared.sadd(room.roomName, process.pid);
            // increase number of rooms spawned on this worker
            memshared.incr(process.pid.toString());
        }
    };
    MatchMaker.prototype.disposeRoom = function (roomName, room) {
        Debug_1.debugMatchMaking("disposing '%s' on worker %d", roomName, process.pid);
        // emit disposal on registered session handler
        this.handlers[roomName].emit("dispose", room);
        delete this.roomsById[room.roomId];
        // remove from cache
        memshared.del(room.roomId);
        // remove from available rooms
        this.lockRoom(roomName, room);
    };
    return MatchMaker;
}());
exports.MatchMaker = MatchMaker;
