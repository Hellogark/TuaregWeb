"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var memshared = require("memshared");
var http = require("http");
var parseURL = require("url-parse");
var uws_1 = require("uws");
var Protocol_1 = require("../Protocol");
var _1 = require("../");
var Debug_1 = require("../Debug");
/**
 * Retrieve and/or set 'colyseusid' cookie.
 */
function setUserId(client) {
    var url = client.upgradeReq.url;
    client.id = url.query['colyseusid'] || _1.generateId();
    if (!url.query['colyseusid']) {
        Protocol_1.send(client, [Protocol_1.Protocol.USER_ID, client.id]);
    }
}
exports.setUserId = setUserId;
function handleUpgrade(server, socket, message) {
    var code = message[0];
    var upgradeReq = message[1];
    var head = message[2];
    var url = parseURL(message[3], true);
    upgradeReq.url = url;
    upgradeReq.roomId = url.pathname.substr(1);
    // assign client socket to request
    upgradeReq.connection = socket;
    // handle 'upgrade' of the WebSocket connection in the worker node
    server.emit('upgrade', upgradeReq, socket, head);
    socket.resume();
}
exports.handleUpgrade = handleUpgrade;
function setupWorker(server, matchMaker) {
    var wss = new uws_1.Server({ server: server });
    // setInterval(() => console.log(`worker ${ process.pid } connections:`, wss.clients.length), 1000);
    wss.on("connection", function (client) {
        setUserId(client);
        var roomId = client.upgradeReq.roomId;
        matchMaker.bindClient(client, roomId);
    });
    process.on('message', function (message, socket) {
        var roomNameOrId = message[1];
        var joinOptions = message[2];
        var allowCreateRoom = (message[0] === Protocol_1.Protocol.CREATE_ROOM);
        if (message[0] === Protocol_1.Protocol.PASS_HTTP_SOCKET) {
            server.emit('connection', socket);
            // re-create request for incoming socket
            var request = new http.ClientRequest({ port: server.address().port });
            request.headers = message[1].headers;
            request.method = message[1].method;
            request.url = message[1].url;
            request.connection = socket;
            request._readableState = socket._readableState;
            // TODO / FIXME:
            //
            // should we flush something here?
            // '_flush' method has been lost after redirecting the socket
            //
            request._flush = function () { };
            request._dump = function () { };
            // emit request to server
            socket.parser.onIncoming(request);
            socket.resume();
            // This is way too hacky.
            request.emit('data', message[1].body);
            request.emit('end');
            return;
        }
        else if (message[0] === Protocol_1.Protocol.PASS_WEBSOCKET) {
            handleUpgrade(server, socket, message);
            return;
        }
        else if (message[0] === Protocol_1.Protocol.REQUEST_JOIN_ROOM) {
            var _a = matchMaker.requestToJoinRoom(message[1], message[2]), room = _a.room, score_1 = _a.score;
            var roomId_1 = room && room.roomId;
            // send response back to match-making process.
            getMatchMakingProcess(function (matchMakingPid) {
                Debug_1.debugMatchMaking("worker '%s' is responding to REQUEST_JOIN_ROOM. (roomId: %s, score: %d)", process.pid, roomId_1, score_1);
                process.send([matchMakingPid, joinOptions.clientId, process.pid, roomId_1, score_1]);
            });
        }
        else if (allowCreateRoom || message[0] === Protocol_1.Protocol.JOIN_ROOM) {
            matchMaker.onJoinRoomRequest(roomNameOrId, joinOptions, allowCreateRoom, function (err, room) {
                var joinRoomResponse = (err)
                    ? [Protocol_1.Protocol.JOIN_ERROR, roomNameOrId, err]
                    : [Protocol_1.Protocol.JOIN_ROOM, room.roomId, joinOptions.requestId];
                // send response back to match-making process.
                getMatchMakingProcess(function (matchMakingPid) {
                    process.send([matchMakingPid, joinOptions.clientId, joinRoomResponse]);
                });
            });
        }
    });
    return server;
}
exports.setupWorker = setupWorker;
function getMatchMakingProcess(callback) {
    memshared.get("matchmaking_process", function (err, matchMakingPid) {
        callback(matchMakingPid);
    });
}
